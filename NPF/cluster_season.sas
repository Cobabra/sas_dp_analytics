/********************************************************************************************************
*
*	PROGRAM: This MACRO finds a set of disjoint clusters of times series based on proporitons of demand over an approapriate seasonal time range
*			or index's or volume
*
*	MACRO PARAMETERS:
*	----Name-------------------Description-------------------------------------------------------------------
*	libn					name of SAS library where input data set resides
*	outlibn					name of SAS library where output data sets reside
*	dsn						data set name of input file
*	outdsn_exc				name of output file containig rows excluded from the cluster training
*	outdsn_center			name of output file with cluster center distribtuion - adds to one for each by variable
*	outdsn_byvar_clusters	name of output file with by by-variables
*	outdsn_byvar_ts			name of output file at the cluster by variable level
*	outdsn_all_ts			name of file that contains the original input file and the cluster column (cluster missing for those excluded)	
*	y 						response variable
*	byvar_clus				by variable level that is used by clustering
*	byvar_low				by variable that identify the lowest level
* 	datevar					date variable name
*	time_int				time interval in the input data set
*	index_cycle				action indicator, if =0, do seasonal clustering, if =1 do index clustering
*	min_ts_length			minimum lenght of time series included in the cluster training		
*	index_no				number of indexes used for each time series where pattern
*	volume_clus				action indicator, if =0, do index or seasonal clustering, if =1, do volume clustering
*	dist					demand pattern metrics for clustering, if =0,emperical demand dist, if =1, Weibull demand dist, if =2, the parameters in Weibull
*	enddate					end date of the historical observations	 
*	maxclus					maximum number of clusters generated by PROC FASTCLUS 
*	threshold				if the incremental performnace measure on adding a cluster (PROC CLUSTER) is less than threshold, then stop 
*	k						cluster parameter used by PROC MODECLUS
*	cluster_method			use Fast=PROC FASTCLUS, or Mode=PROC MODECLUS  
*	cluster_distance_metric	distance metrix to use, e.g. Ward or Density
*	cluster_name			name of cluster variable
*	likelihood_name			name of likelihood vector
*	likelihood_loess_name	name of Loess likelihood smooth vector
*----set in MACRO-----*
*	prefix_use		prefix for distribution variables
*	==================================================================================================================
*   AUTHOR:	Christian Haxholdt, Ph.D. (christian.haxholdt@sas.com), SAS Professional Services & Delivery, Cary, NC, USA
*
*	CREATED:	February, 2015
*  	 
********************************************************************************************************************/


/* ==== Cluster Macro === */

%MACRO cluster_season(	libn=, 
						outlibn=, 
						dsn=,
						outdsn_exc=exc,
						outdsn_center=center,
						outdsn_byvar_ts=byvar_ts,
						outdsn_all_ts=orig_clus, 
						y=,
						byvar_clus=,
						byvar_low=,
						datevar=, 
						time_int=, 
						index_cycle=0,
						min_ts_length=12,
						index_no=0,
						dist=0,
						enddate=, 
						maxclus=200,
						minclus=2, 
						threshold=0.02, 
						k=10,
						cluster_method=Fast,
						cluster_distance_metric=ward,
						cluster_name=cluster,
						likelihood_name=likelihood,
						likelihood_loess_name=likelihood_loess
						);

%local clus_method align_s cluster_q;

%local prefix_use;

%let prefix_use=L_;

%let cluster_q=1;

ods noresults;
/*==================================================================================================================================*/
/* Determine 'end' and 'start'				                                                     	*/
/*==================================================================================================================================*/

%if (&time_int=month) %then %do; 
	%let no_timeint=12;
	%if (&min_ts_length= or &min_ts_length=0) %then %do;
		%let min_ts_length=3;
		%put ERROR: The parameter min_ts_length is set to zero or missing, it is changed to 3;
	%end; 
	%if (&index_no= or &index_no=0) %then %let index_no=12; 
%end;
%else %do;
	%let no_timeint=52;
	%if (&min_ts_length= or &min_ts_length=0) %then %do;
		%let min_ts_length=12;
		%put ERROR: The parameter min_ts_length is set to zero or missing, it is changed to 12;
	%end;
	%if (&index_no= or &index_no=0) %then %let index_no=52; 
%end;

/*==================================================================================================================================*/
/* Program check if parameter setting for cluster is wrong					                               	*/
/*==================================================================================================================================*/

%if (&cluster_method=Fast or &cluster_method=Mode) %then %do;
%end;
%else %do;
	%let cluster_method=Fast;
	%put ERROR: The parameter Cluster_method in macro call, must equal 'Fast' or 'Mode' - it is set to 'Fast';
%end;
%if (&index_cycle>1) %then %do;
	%let index_cycle=0;
	%put ERROR: The parameter index_cycle is not in (0,1) - it is set to 0;
%end;
%if not (&dist=0 or &dist=1 or &dist=2) %then %do;
	%let dist=0;
	%put ERROR: The parameter dist is not in (0,1,2) - it is set to 0;
%end;

/*==================================================================================================================================*/
/* Sort data set and add index and season */
/*==================================================================================================================================*/

	PROC SORT data=&dsn.  out=&outlibn..dsn_sort;
		by &byvar_clus &datevar;
	RUN;QUIT; 

	PROC TIMEDATA data=&outlibn..dsn_sort out=_null_ outarray=&outlibn..timedata;
      by &byvar_clus;
      id &datevar interval=&time_int ACCUMULATE=total;
      var &y;
   	RUN;QUIT;

/*==================================================================================================================================*/
/* Sort data set and add index and season				                                  	*/
/*==================================================================================================================================*/

	PROC SORT data=&outlibn..timedata;
		by &byvar_clus _cycle_ &datevar;
	RUN;QUIT;

	PROC MEANS data=&outlibn..timedata noprint;
		by &byvar_clus;
		var _cycle_;
		output out=&outlibn..max_cycle max=high;
	RUN;QUIT;

	DATA &outlibn..train_cluster(drop=_type_ _freq_ high)  &libn..&outdsn_exc(drop=_type_ _freq_ high);
		merge &&outlibn..timedata  &outlibn..max_cycle(in=a);
		by &byvar_clus;
		if a;
		if (&y<0 or missing(&y)) then &y=0;
		if (high < &min_ts_length) then output &libn..&outdsn_exc;
		else do;
			if (_CYCLE_ > &index_no and &index_cycle=1) then delete;
			output &outlibn..train_cluster;
		end;
	RUN;

	PROC SORT data=&outlibn..train_cluster;
		by &byvar_clus &datevar;
	RUN;QUIT;

/*=====================================================================================================================================*/
/* Index=0. Aggregate to byvar level, and create season file. Estimate SEASONAL likelihood of demand by byvar and create transpose*/
/*=====================================================================================================================================*/	

%if (&index_cycle=0) %then %do;
	PROC TIMESERIES data=&outlibn..train_cluster out=&outlibn..aggdata outseason=&outlibn..outseason(rename=(_season_=T_&time_int));
		by &byvar_clus;
		id &datevar interval=&time_int end=&enddate;
		var &y / accumulate=total;
	RUN;QUIT;

	PROC MEANS data=&outlibn..outseason noprint;
		var mean;
		by &byvar_clus;
		output out=&outlibn..sum_season(drop=_type_ _freq_) sum(mean)=Sum_mean;
	RUN;QUIT; 
	
	DATA &outlibn..probability_dist;
		merge &outlibn..sum_season &outlibn..outseason;
		by &byvar_clus;
		if (Sum_mean ne 0 and not missing(mean)) then do;
			&likelihood_name=mean/Sum_mean;
		end;
		else &likelihood_name = 0;
	RUN;

	PROC TRANSPOSE data=&outlibn..probability_dist prefix=&prefix_use out=&outlibn..Prob_transpose(drop=_name_);
		by &byvar_clus;
		var &likelihood_name;
		id T_&time_int;
	*	where nmiss(&likelihood_name)=0;
	RUN;QUIT;

	DATA &outlibn..Prob_transpose (drop=i);
		set &outlibn..Prob_transpose;
		array varlist {*} &prefix_use:;
		do i=1 to dim(varlist);
			if varlist{i}=. then varlist{i}=0;
		end;
	RUN; 
%end;

/*==================================================================================*/
/* Generate Index cycle using Weibull distribution */
/*==================================================================================*/

%if (&index_cycle=1 and (&dist=1 or &dist=2)) %then %do;
	PROC SEVERITY data=&outlibn..train_cluster crit=aicc 
			OUTCDF=&outlibn..outcdf
			OUTEST=&outlibn..outest 
			noprint;
		by &byvar_clus;
		weight &y; 
		loss _cycle_;
		dist weibull;
	RUN;QUIT;
%end;

/*==================================================================================*/
/* Estimate index likelihood of demand by byvar and create transpose */
/*==================================================================================*/

%if (&index_cycle=1) %then %do;
	PROC MEANS data=&outlibn..train_cluster noprint;
		var &y;
		by &byvar_clus;
		output out=&outlibn..sum_season(drop=_type_ _freq_) sum(&y)=Sum_mean;
	RUN;QUIT; 
	
	DATA &outlibn..probability_dist(rename=(_cycle_=T_&time_int));
		merge &outlibn..sum_season &outlibn..train_cluster;
		by &byvar_clus;
		if (Sum_mean ne 0 and not missing(&y)) then do;
			&likelihood_name=&y/Sum_mean;
		end;
		else &likelihood_name = 0;
	RUN;

	%if (&dist=0) %then %do;
		PROC TRANSPOSE data=&outlibn..probability_dist prefix=&prefix_use out=&outlibn..Prob_transpose(drop=_name_);
			by &byvar_clus;
			var &likelihood_name;
			id T_&time_int;
		RUN;QUIT;

		DATA &outlibn..Prob_transpose (drop=i);
			set &outlibn..Prob_transpose;
			array varlist {*} &prefix_use:;
			do i=1 to dim(varlist);
				if varlist{i}=. then varlist{i}=0;
			end;
		RUN;
	%end;

	%if (&dist=1) %then %do;
		DATA &outlibn..Probability_dist_w(rename=(_cycle_=T_&time_int));
			set &outlibn..outcdf;
			&likelihood_name=WEIBULL_CDF;
			drop _OBSNUM_ _EDF_ _EDF_STD _EDF_LOWER _EDF_UPPER WEIBULL_CDF;
		RUN;

		PROC SORT data=&outlibn..Probability_dist_w;
			by &byvar_clus;
		RUN;QUIT;

		PROC TRANSPOSE data=&outlibn..Probability_dist_w prefix=&prefix_use out=&outlibn..Prob_transpose(drop=_name_);
			by &byvar_clus;
			var &likelihood_name;
			id T_&time_int;
		RUN;QUIT;

		DATA &outlibn..Prob_transpose (drop=i);
			set &outlibn..Prob_transpose;
			array varlist {*} &prefix_use:;
			do i=1 to dim(varlist);
				if varlist{i}=. then varlist{i}=0;
			end;
		RUN;
	%end;

	%if (&dist=2) %then %do;
		DATA &outlibn..Prob_transpose(drop= _MODEL_ _TYPE_ _STATUS_ Theta Tau);
			set &outlibn..outest;
			if (_TYPE_='STDERR') then delete;
			L_1=Theta; 
			L_2=Tau;
		RUN;
	%end;

%end;
	

/*==================================================================================*/
/* Perform cluster analysis*/
/*==================================================================================*/		

%if (&cluster_method=Fast) %then %do;
	PROC FASTCLUS data=&outlibn..Prob_transpose summary maxc=&maxclus maxiter=99 converge=0 drift cluster=Pre_Clus_Fast out=&outlibn..pre_clus_fast mean=&outlibn..cluster_mean noprint;
		var &prefix_use:;
	RUN;QUIT;

	PROC MEANS data=&outlibn..pre_clus_fast noprint;
		var Pre_Clus_Fast;
		output out=&outlibn..pre_clus_fast_stat(drop=_type_ _freq_) STD(Pre_Clus_Fast)=STD;
	RUN;QUIT; 

	DATA _NULL_;
		set &outlibn..pre_clus_fast_stat;
		if (STD=0) then do;
		 	call symput('cluster_q',0);
		end;
	RUN;

	%if (&cluster_q=1) %then %do;
		PROC CLUSTER data=&outlibn..cluster_mean method=&cluster_distance_metric pseudo ccc outtree=&outlibn..cluster_tree;
			var &prefix_use:;
			copy Pre_Clus_Fast;
		RUN;QUIT;

		PROC SORT data=&outlibn..cluster_tree;
			by _NCL_;
		RUN;

		DATA &outlibn..optimal_clusters(drop=Pre_Clus_Fast);
			set &outlibn..cluster_tree;
		 	if (_SPRSQ_ < &threshold and _NCL_>&minclus) then delete;
		RUN;

		DATA &outlibn..optimal_clusters;
			set &outlibn..optimal_clusters;
			call symput('ncl_F', _ncl_);
		RUN;

		PROC TREE data=&outlibn..cluster_tree ncl=&ncl_F out=&outlibn..tree(rename=(cluster=_cluster_)) noprint;
			copy Pre_Clus_Fast;
		RUN;QUIT;
	%end;
	%else %do;
		DATA &outlibn..tree(drop=&prefix_use:);
			set &outlibn..pre_clus_fast;
			_cluster_=Pre_Clus_Fast;
			_NAME_=.;
			clusname=.;
			put ERROR: There is only one cluster generated from PROC FASTCLUS;
		RUN;
	%end;
%end;

/*%if (&cluster_method=Mode) %then %do;*/
/*	PROC MODECLUS data=&outlibn..Prob_transpose m=1 k=&k out=&outlibn..mode_clus_season;*/
/*		var &prefix_use:;*/
/*	RUN;QUIT;*/
/*%end;*/

/*==================================================================================*/
/* Merge FAST Cluster results back on original data set */
/*==================================================================================*/

%if (&cluster_method=Fast) %then %do;
	PROC SORT data=&outlibn..pre_clus_fast;
		by Pre_Clus_Fast;
	RUN;QUIT; 
	
	PROC SORT data=&outlibn..tree;
		by Pre_Clus_Fast;
	RUN;QUIT;

	DATA &outlibn..fast_clus_season(drop = _cluster_ distance clusname _NAME_  pre_clus_fast);
		merge &outlibn..pre_clus_fast &outlibn..tree;
		by Pre_Clus_Fast;
		if (_cluster_=.) then &cluster_name=0;
		&cluster_name=_cluster_;
	RUN; 

	PROC SORT data=&outlibn..fast_clus_season;
		by &byvar_clus;
	RUN;QUIT;

	DATA &outlibn..cluster_center_calc;
		merge &outlibn..probability_dist &outlibn..fast_clus_season;
		by &byvar_clus;
	RUN;

	PROC SORT data=&outlibn..cluster_center_calc;
		by &cluster_name;
	RUN;QUIT;

	PROC MEANS data=&outlibn..cluster_center_calc noprint;
		var &likelihood_name;
		by &cluster_name;
		output out=&outlibn..sum_cluster(drop=_type_ _freq_) sum(&likelihood_name)=Sum_cluster;
	RUN;QUIT; 

	PROC SORT data=&outlibn..cluster_center_calc;
		by &cluster_name. T_&time_int.;
	RUN;QUIT;

	PROC MEANS data=&outlibn..cluster_center_calc noprint;
		var &likelihood_name.;
		by &cluster_name. T_&time_int.;
		output out=&outlibn..sum_index(drop=_type_ _freq_) sum(&likelihood_name.)=Sum;
	RUN;QUIT; 
	
	DATA &libn..&outdsn_center(drop=sum sum_cluster rename=(T_&time_int=_CYCLE_));
		merge &outlibn..sum_index &outlibn..sum_cluster;
		by &cluster_name.;
		if (Sum_cluster ne 0) then do;
			&likelihood_name.=sum/Sum_cluster;
		end;
		else &likelihood_name.= 0;
	RUN;

	
* BEGIN Add Loess probabilities, if > weeks>12 or months>6;
*-------------------------------------------------------------------------------------------------------------------;

	%if ((&time_int.=week and &min_ts_length. ge 12)or(&time_int.=month and &min_ts_length. ge 3)) %then %do;
		PROC LOESS data=&libn..&outdsn_center.;
			by &cluster_name.;
			model &likelihood_name.=_CYCLE_ / smooth=0.9 direct;
			output out=&outlibn..Loess_result predicted=Predicted;
		RUN;QUIT;

		DATA &outlibn..Loess_result;
			set &outlibn..Loess_result;
			if (predicted<0) then predicted=&likelihood_name;
		RUN;

		PROC MEANS data=&outlibn..Loess_result noprint;
			var Predicted;
			by &cluster_name;
			output out=&outlibn..sum_index_loess(drop=_type_ _freq_) sum(Predicted)=Sum;
		RUN;QUIT; 
		
		DATA &libn..&outdsn_center.(drop=sum predicted SmoothingParameter--Obs);
			merge &outlibn..sum_index_loess &outlibn..Loess_result;
			by &cluster_name;
			if (Sum ne 0) then do;
				&likelihood_loess_name=predicted/Sum;
			end;
			else &likelihood_loess_name=0;
		RUN;
	%end;


* END Add Loess probabilities, if > weeks>12 or months>6;
*-------------------------------------------------------------------------------------------------------------------;

	DATA &libn..&outdsn_byvar_ts(drop=&prefix_use:);
		merge &outlibn..timedata &outlibn..fast_clus_season;
		by &byvar_clus;
	RUN;
	
	DATA &libn..&outdsn_all_ts;
		merge &outlibn..dsn_sort &libn..&outdsn_byvar_ts;
		by &byvar_clus &datevar;
	RUN;

	PROC SORT data=&libn..&outdsn_all_ts;
		by &byvar_low &datevar;
	RUN;QUIT; 
%end;

/*&cluster_name=put(cluster,4.0)*/
/*==================================================================================*/
* Merge Mode back on original data set;
/*==================================================================================*/

/*	%if (&cluster_method=Mode) %then %do;	*/
/*		PROC SORT data=&outlibn..mode_clus_season out=&libn..&outdsn_cluster;*/
/*			by &byvar_clus;*/
/*		RUN;QUIT;*/
/**/
/*		DATA &libn..&outdsn_all(drop = Cluster DENSITY _OBS_ _METHOD_ _K_ &prefix_use:);*/
/*			merge &outlibn..data_ready &libn..&outdsn_cluster;*/
/*			by &byvar_clus;*/
/*			if (cluster=.) then cluster=0;*/
/*			&cluster_name=cluster;*/
/*		RUN;*/
/*	%end;*/

/*==================================================================================*/
/*   delete intermediate files */
/*==================================================================================*/

	PROC DATASETS library=&outlibn memtype=data nolist;
		delete	dsn_sort
				timedata 
				max_cycle
				train_cluster
				aggdata
				sum_season 
				sum_&time_int
				outseason
				outcdf
				outest
				probability_dist
				probability_dist_w 
				Prob_Transpose 
				cluster_mean
				pre_clus_fast
				pre_clus_fast_stat
				cluster_tree
				optimal_clusters
				tree 
				sum_cluster
				sum_index
				cluster_center_calc
				Loess_result
				sum_index_loess
				fast_clus_season 
				mode_clus_season
				;
	RUN;QUIT;
	
%MEND cluster_season;

/*%cluster_season(	libn=ss, */
/*					outlibn=ss_out, */
/*					dsn=ss.pricedata_new,*/
/*					y=sale,*/
/*					byvar_clus=regionname productline productname,*/
/*					byvar_low=productname,*/
/*					datevar=start_dt, */
/*					time_int=month, */
/*					enddate='01dec2002'd */
/*					);*/

/**/
/*%cluster_season(	libn=ss, */
/*					outlibn=ss, */
/*					dsn=ss.train,*/
/*					y=order_qty,*/
/*					byvar_clus=PRODUCT_id STORE_LOCATION_ID,*/
/*					byvar_low=PRODUCT_id STORE_LOCATION_ID,*/
/*					datevar=start_dt, */
/*					time_int=week,*/
/*					enddate='31mar2015'd*/
/*					);*/