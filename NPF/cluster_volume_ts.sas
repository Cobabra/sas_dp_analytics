/********************************************************************************************************
*
*	PROGRAM: This MACRO finds a set of disjoint clusters of times series based on volmue of demand over an approapriate seasonal time range
*			or index's or volume
*
*	MACRO PARAMETERS:
*	----Name-------------------Description-------------------------------------------------------------------
*	libn					name of SAS library where input data set resides
*	outlibn					name of SAS library where output data sets reside
*	dsn						data set name of input file - format e.g. 'ss.pricedata'
*	outdsn_exc				name of output file containig rows excluded from the cluster training
*	outdsn_center			name of output file with cluster center distribtuion - adds to one for each by variable
*	outdsn_byvar			name of output file at the cluster by variable level
*	outdsn_all				name of file that contains the original input file and the cluster column	
*	y 						response variable
*	byvar_clus				by variables level that is used by clustering
*	byvar_low				by variables that identify the lowest level
* 	datevar					date variable name
*	time_int				time interval in the input data set
*	index_cycle				action indicator, if =0, do seasonal clustering, if =1 do index clustering
*	min_ts_length			minimum lenght of time series included in the cluster training		
*	index_no				number of indexes used for each time series where volume clustering is performed	
*	enddate					end date of the historical observations	 
*	maxclus					maximum number of clusters generated by PROC FASTCLUS 
*	threshold				if the incremental performnace measure on adding a cluster (PROC CLUSTER) is less than threshold, then stop 
*	k						cluster parameter used by PROC MODECLUS
*	cluster_method			use Fast=PROC FASTCLUS, or Mode=PROC MODECLUS  
*	cluster_distance_metric	distance metrix to use, e.g. Ward or Density
*	cluster_name			name of cluster variable - default is 'cluster'
*----set in MACRO-----*
*	prefix_use		prefix for distribution variables
*	==================================================================================================================
*   AUTHOR:	Christian Haxholdt, Ph.D. (christian.haxholdt@sas.com), SAS Professional Services & Delivery, Cary, NC, USA
*
*	CREATED:	February, 2015
*  	 
********************************************************************************************************************/


/* ==== Cluster Macro === */

%MACRO cluster_volume_ts(	libn=, 
							outlibn=, 
							dsn=,
							outdsn_exc=ext,
							outdsn_center=center,
							outdsn_byvar=byvar,
							outdsn_all=orig_clus,
							y=,
							byvar_clus=,
							byvar_low=,
							datevar=, 
							time_int=,
							index_cycle=0, 
							min_ts_length=0,
							index_no=,
							enddate=, 
							maxclus=200,
							minclus=2, 
							threshold=0.02, 
							k=10,
							cluster_method=Fast,
							cluster_distance_metric=ward,
							cluster_name=cluster
							);

%local prefix_use;

%let prefix_use=L_;

ods noresults;
/*==================================================================================================================================*/
/* Determine 'end' and 'start' */				                                                   
/*==================================================================================================================================*/
%local cluster_q;

%if (&time_int=month) %then %do; 
	%if (&index_no= or &index_no=0) %then %let index_no=12; 
%end;
%else %do;
	%if (&index_no= or &index_no=0) %then %let index_no=52; 
%end;

%let cluster_q=1;

/*==================================================================================================================================*/
/* Program abort if parameter setting for cluster is wrong					*/		
/*==================================================================================================================================*/

%if (&cluster_method=Fast or &cluster_method=Mode) %then %do;
%end;
%else %do;
	%let cluster_method=Fast;
	%put ERROR: The parameter Cluster_method in macro call, must equal 'Fast' or 'Mode' - it is set to 'Fast';
%end;

/*==================================================================================================================================*/
/* Sort data set and add index and season */	
/*==================================================================================================================================*/

	PROC SORT data=&dsn out=&outlibn..dsn_sort;
		by &byvar_clus &datevar;
	RUN;QUIT; 

	PROC TIMEDATA data=&outlibn..dsn_sort out=_null_ outarray=&outlibn..timedata;
      by &byvar_clus;
      id &datevar interval=&time_int ACCUMULATE=total;
      var &y;
   	RUN;QUIT;

/*==================================================================================================================================*/
/* Create a training data set for clustering */															
/*==================================================================================================================================*/

	PROC SORT data=&outlibn..timedata;
		by &byvar_clus _cycle_ &datevar;
	RUN;QUIT;

	PROC MEANS data=&outlibn..timedata noprint;
		by &byvar_clus;
		var _cycle_;
		output out=&outlibn..max_cycle max=high;
	RUN;QUIT;

	DATA &outlibn..train_cluster(drop=_type_ _freq_ high) &libn..&outdsn_exc(drop=_type_ _freq_ high);
		merge &&outlibn..timedata &outlibn..max_cycle(in=a);
		by &byvar_clus;
		if a;
		if (&y<0 or missing(&y)) then &y=0;
		if (high < &min_ts_length) then output &libn..&outdsn_exc;
		else do;
			if (_CYCLE_ > &index_no and &index_cycle=1) then delete;
			output &outlibn..train_cluster;
		end;
	RUN;

/*==================================================================================================================================*/
/* Prepare the index clustering training data */															
/*==================================================================================================================================*/

%if (&index_cycle=1) %then %do;
	PROC SORT data=&outlibn..train_cluster;
		by &byvar_clus &datevar;
	RUN;QUIT;

	PROC MEANS data=&outlibn..train_cluster noprint;
		by &byvar_clus;
		var &y;
		output out=&outlibn..Prob_transpose(drop=_type_ _freq_) sum(&y)=&prefix_use.v;
	RUN;QUIT; 
%end;

/*==================================================================================*/
/* Prepare the seasonal (non-indexed) clustering training data */
/*==================================================================================*/	

%if (&index_cycle=0) %then %do;
	PROC TIMESERIES data=&outlibn..train_cluster out=&outlibn..aggdata outseason=&outlibn..outseason(rename=(_season_=T_&time_int));
		by &byvar_clus;
		id &datevar interval=&time_int end=&enddate;
		var &y / accumulate=total;
	RUN;QUIT;

	PROC MEANS data=&outlibn..outseason noprint;
		var mean;
		by &byvar_clus;
		output out=&outlibn..sum_season(drop=_type_ _freq_) sum(mean)=Sum_mean;
	RUN;QUIT; 
	
	DATA &outlibn..probability_dist;
		merge &outlibn..sum_season &outlibn..outseason;
		by &byvar_clus;
		if (Sum_mean ne 0) then do;
			&likelihood_name=mean/Sum_mean;
		end;
		else &likelihood_name = 0;
		%let dist=0;
	RUN;

	PROC TRANSPOSE data=&outlibn..probability_dist prefix=&prefix_use out=&outlibn..Prob_transpose(drop=_name_);
		by &byvar_clus;
		var &likelihood_name;
		id T_&timeint_season;
	*	where nmiss(&likelihood_name)=0;
	RUN;QUIT;

	DATA &outlibn..Prob_transpose (drop=i);
		set &outlibn..Prob_transpose;
		array varlist {*} &prefix_use:;
		do i=1 to dim(varlist);
			if varlist{i}=. then varlist{i}=0;
		end;
	RUN; 
%end;

/*==================================================================================*/
/* Perform cluster analysis */
/*==================================================================================*/			

%if (&cluster_method=Fast) %then %do;
	PROC FASTCLUS data=&outlibn..Prob_transpose summary maxc=&maxclus maxiter=99 converge=0 drift cluster=Pre_Clus_Fast out=&outlibn..pre_clus_fast mean=&outlibn..cluster_mean noprint;
		var &prefix_use:;
	RUN;QUIT;

	PROC MEANS data=&outlibn..pre_clus_fast noprint;
		var Pre_Clus_Fast;
		output out=&outlibn..pre_clus_fast_stat(drop=_type_ _freq_) STD(Pre_Clus_Fast)=STD;
	RUN;QUIT; 

	DATA _NULL_;
		set &outlibn..pre_clus_fast_stat;
		if (STD=0) then do;
		 	call symput('cluster_q',0);
		end;
	RUN;

	%if (&cluster_q=1) %then %do;
		PROC CLUSTER data=&outlibn..cluster_mean method=&cluster_distance_metric pseudo ccc outtree=&outlibn..cluster_tree;
			var &prefix_use:;
			copy Pre_Clus_Fast;
		RUN;QUIT;


		PROC SORT data=&outlibn..cluster_tree;
			by _NCL_;
		RUN;

		DATA &outlibn..optimal_clusters;
			set &outlibn..cluster_tree;
		 	if (_SPRSQ_ < &threshold and _NCL_>&minclus) then delete;
		RUN;

		DATA &outlibn..optimal_clusters;
			set &outlibn..optimal_clusters;
			call symput('ncl_F', _ncl_);
		RUN;

		PROC TREE data=&outlibn..cluster_tree ncl=&ncl_F out=&outlibn..tree(rename=(cluster=_cluster_)) noprint;
			copy Pre_Clus_Fast;
		RUN;QUIT;
	%end;
	%else %do;
		DATA &outlibn..tree(drop=&prefix_use:);
			set &outlibn..pre_clus_fast;
			_cluster_=Pre_Clus_Fast;
			_NAME_=.;
			clusname=.;
			put ERROR: There is only one cluster generated from PROC FASTCLUS;
		RUN;
	%end;
%end;

%if (&cluster_method=Mode) %then %do;
	PROC MODECLUS data=&outlibn..Prob_transpose m=1 k=&k out=&outlibn..mode_clus_season;
		var &prefix_use:;
	RUN;QUIT;
%end;

/*==================================================================================*/
/* Merge FAST Cluster results back on original data set */
/*==================================================================================*/

%if (&cluster_method=Fast) %then %do;
	PROC SORT data=&outlibn..pre_clus_fast;
		by Pre_Clus_Fast;
	RUN;QUIT; 
	
	PROC SORT data=&outlibn..tree;
		by Pre_Clus_Fast;
	RUN;QUIT;

	DATA &outlibn..fast_clus_season(drop = _cluster_ distance clusname _NAME_  pre_clus_fast);
		merge &outlibn..pre_clus_fast &outlibn..tree;
		by Pre_Clus_Fast;
		if (_cluster_=.) then &cluster_name=0;
		&cluster_name=_cluster_;
	RUN; 

	PROC SORT data=&outlibn..fast_clus_season;
		by &byvar_clus;
	RUN;QUIT;

	PROC SORT data=&outlibn..fast_clus_season out=&outlibn..cluster_center;
		by &cluster_name;
	RUN;QUIT;

	PROC MEANS data=&outlibn..cluster_center noprint;
		by &cluster_name;
		var &prefix_use:;
		output out=&libn..&outdsn_center(drop=_type_ _freq_) mean=mean median=median std=std max=max min=min N=N;
	RUN;QUIT;

	DATA &libn..&outdsn_byvar(drop=&prefix_use:);
		merge &outlibn..timedata &outlibn..fast_clus_season;
		by &byvar_clus;
	RUN;
	
	DATA &libn..&outdsn_all;
		merge &outlibn..dsn_sort &libn..&outdsn_byvar;
		by &byvar_clus &datevar;
	RUN;

	PROC SORT data=&libn..&outdsn_all;
		by &byvar_low &datevar;
	RUN;QUIT; 
%end;

/*&cluster_name=put(cluster,4.0)*/
/*==================================================================================*/
/* Merge Mode back on original data set */
/*==================================================================================*/
/*
	%if (&cluster_method=Mode) %then %do;	
		PROC SORT data=&outlibn..mode_clus_season out=&libn..&outdsn_cluster;
			by &byvar_clus;
		RUN;QUIT;

		DATA &libn..&outdsn_all(drop = Cluster DENSITY _OBS_ _METHOD_ _K_ &prefix_use:);
			merge &outlibn..data_ready &libn..&outdsn_cluster;
			by &byvar_clus;
			if (cluster=.) then cluster=0;
			&cluster_name=cluster;
		RUN;
	%end;

/*==================================================================================*/
/*   delete intermediate files */
/*==================================================================================*/

	PROC DATASETS library=&outlibn memtype=data nolist;
		delete  dsn_sort
				timedata 
				max_cycle
				train_cluster
				aggdata
				outseason
				sum_season
				probability_dist
				sum_
				Prob_Transpose 
				cluster_mean
				pre_clus_fast
				pre_clus_fast_stat
				cluster_tree
				optimal_clusters
				tree 
				sum_cluster
				cluster_center_calc
				cluster_center
				fast_clus_season 
				mode_clus_season
				;
	RUN;QUIT;  

%MEND;

/*libname ss "C:\Users\chhaxh\Documents\SAS_CODE_DATA\Clustering\DATA\ss";*/
/*libname ss_out "C:\Users\chhaxh\Documents\SAS_CODE_DATA\Clustering\DATA\ss_out";*/


/*%cluster_volume_ts(	libn=ss, */
/*					outlibn=ss_out, */
/*					dsn=ss.pricedata_new, */
/*					y=sale,*/
/*					byvar_clus=regionname productline productname,*/
/*					byvar_low=productname,*/
/*					datevar=start_dt, */
/*					time_int=month, */
/*					enddate='01dec2002'd */
/*					);*/